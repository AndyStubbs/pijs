<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Pi.js 2.0 - API Inspector</title>
	<style>
		body {
			margin: 0;
			padding: 20px;
			font-family: monospace;
			background: #222;
			color: #fff;
		}
		h1 {
			color: #4CAF50;
		}
		.section {
			margin: 20px 0;
			padding: 15px;
			background: #333;
			border-radius: 5px;
		}
		.section h2 {
			margin-top: 0;
			color: #FFC107;
		}
		.command-list {
			background: #1a1a1a;
			padding: 15px;
			border-radius: 3px;
			max-height: 500px;
			overflow-y: auto;
		}
		.command {
			padding: 3px 0;
			color: #4CAF50;
		}
		.count {
			color: #4CAF50;
			font-weight: bold;
		}
		.status {
			color: #FFC107;
			font-style: italic;
		}
		.category {
			color: #2196F3;
			font-weight: bold;
			margin-top: 10px;
			margin-bottom: 5px;
		}
		canvas {
			margin: 20px 0;
			display: block;
		}
	</style>
</head>
<body>
	<h1>Pi.js 2.0 API Inspector</h1>
	<p>Inspecting the current API structure...</p>

	<div id="results"></div>

	<script>
		const results = document.getElementById( "results" );
		
		// Load and compare both versions
		let legacyAPI = null;
		let currentAPI = null;

		// Helper to extract API methods from a pi object
		function extractAPIMethods( piObj ) {
			const methods = {
				"global": [],
				"screen": []
			};

			// Get global methods
			for( const key in piObj ) {
				if( key === "_" || key === "util" || key === "version" ) {
					continue;
				}
				if( typeof piObj[ key ] === "function" ) {
					methods.global.push( key );
				}
			}

			// Get screen methods
			try {
				const testScreen = piObj.screen ? piObj.screen( "1x1" ) : null;
				if( testScreen ) {
					for( const key in testScreen ) {
						if( typeof testScreen[ key ] === "function" ) {
							methods.screen.push( key );
						}
					}
					piObj.removeAllScreens();
				}
			} catch( e ) {
				console.warn( "Could not enumerate screen methods:", e );
			}

			return methods;
		}

		// Load legacy version first
		async function loadLegacy() {
			return new Promise( ( resolve, reject ) => {
				const script = document.createElement( "script" );
				script.src = "../releases/pi-1.2.4.js";
				script.onload = () => {
					if( window.pi ) {
						legacyAPI = extractAPIMethods( window.pi );
						
						// Clean up legacy pi from window
						delete window.pi;
						delete window.$;
						
						resolve();
					} else {
						reject( new Error( "Legacy pi.js not found" ) );
					}
				};
				script.onerror = () => reject( new Error( "Could not load pi-1.2.4.js" ) );
				document.head.appendChild( script );
			} );
		}

		// Load current version
		async function loadCurrent() {
			return new Promise( ( resolve, reject ) => {
				const script = document.createElement( "script" );
				script.src = "../build/pi.js";
				script.onload = () => {
					if( window.pi ) {
						currentAPI = extractAPIMethods( window.pi );
						resolve();
					} else {
						reject( new Error( "Current pi.js not found" ) );
					}
				};
				script.onerror = () => reject( new Error( "Could not load pi.js" ) );
				document.head.appendChild( script );
			} );
		}

		// Helper to fetch file size
		async function getFileSize( url ) {
			try {
				const response = await fetch( url );
				if( response.ok ) {
					const blob = await response.blob();
					return blob.size;
				}
			} catch( e ) {
				console.warn( `Could not fetch size for ${url}` );
			}
			return null;
		}

		// Helper to format bytes
		function formatBytes( bytes ) {
			if( bytes === null ) return "N/A";
			if( bytes < 1024 ) return `${bytes} B`;
			if( bytes < 1024 * 1024 ) return `${(bytes / 1024).toFixed(2)} KB`;
			return `${(bytes / (1024 * 1024)).toFixed(2)} MB`;
		}

		async function inspectAPI() {
			try {
				// Use $ alias (pi.js loaded as IIFE)
				const pi = window.pi;
				const $ = window.$;

				// Verify pi is loaded
				if( !pi ) {
					throw new Error( "Pi.js not loaded. window.pi is undefined." );
				}

				// Fetch file sizes
				const sizes = {
					"unminified": await getFileSize( "../build/pi.js" ),
					"minified": await getFileSize( "../build/pi.min.js" ),
					"esm": await getFileSize( "../build/pi.esm.min.js" ),
					"cjs": await getFileSize( "../build/pi.cjs.min.js" )
				};

				// Create status section
				const statusSection = document.createElement( "div" );
				statusSection.className = "section";
				statusSection.innerHTML = `
					<h2>Pi.js v${pi.version}</h2>
					<h2>Refactor Progress: Phases 0-17 Complete âœ… (81%)</h2>
					<div class="status">
						<ul>
							<li>âœ… Phase 0-4: Foundation, Core, Screen, Helpers, Drawing</li>
							<li>âœ… Phase 6-7: Paint/Fill, Bezier Curves</li>
							<li>âœ… Phase 8-10: Images, Fonts/Text, Tables</li>
							<li>âœ… Phase 11-14: Input (Keyboard, Mouse, Touch, Gamepad)</li>
							<li>âœ… Phase 15-17: Sound, PLAY, Palette & Settings</li>
							<li>ðŸ”„ Phase 18-20: Testing, Documentation, Release</li>
						</ul>
					</div>
				`;
				results.appendChild( statusSection );

				// Create bundle size section
				const sizeSection = document.createElement( "div" );
				sizeSection.className = "section";
				sizeSection.innerHTML = "<h2>Bundle Sizes</h2>";
				
				const sizeList = document.createElement( "div" );
				sizeList.className = "command-list";
				
				sizeList.innerHTML = `
					<div class="command">
						<span class="count">Unminified (IIFE):</span> 
						${formatBytes( sizes.unminified )}
					</div>
					<div class="command">
						<span class="count">Minified (IIFE):</span> 
						${formatBytes( sizes.minified )}
					</div>
					<div class="command">
						<span class="count">ESM (minified):</span> 
						${formatBytes( sizes.esm )}
					</div>
					<div class="command">
						<span class="count">CJS (minified):</span> 
						${formatBytes( sizes.cjs )}
					</div>
				`;

				// Add compression ratio if both sizes available
				if( sizes.unminified && sizes.minified ) {
					const ratio = ((1 - sizes.minified / sizes.unminified) * 100).toFixed(1);
					sizeList.innerHTML += `
						<div class="command">
							<span class="count">Compression:</span> 
							${ratio}% smaller when minified
						</div>
					`;
				}
				
				sizeSection.appendChild( sizeList );
				results.appendChild( sizeSection );

				// Get all public API methods (exclude internal, util, version, _)
				const publicMethods = [];
				const screenMethods = [];
				
				for( const key in pi ) {
					if( key === "_" || key === "util" || key === "version" ) {
						continue;
					}
					if( typeof pi[ key ] === "function" ) {
						publicMethods.push( key );
					}
				}

			// Get screen methods by creating a test screen
			try {
				// Verify both pi.screen and $.screen exist and are the same
				console.log( "pi.screen exists:", typeof pi.screen === "function" );
				console.log( "$.screen exists:", typeof $.screen === "function" );
				console.log( "pi.screen === $.screen:", pi.screen === $.screen );

				// Create a test screen (both should work)
				const testScreen = pi.screen( { "aspect": "1x1", "noStyles": true } );
				if( testScreen ) {
					for( const key in testScreen ) {
						if( typeof testScreen[ key ] === "function" ) {
							screenMethods.push( key );
						}
					}
					pi.removeAllScreens();
				}
			} catch( e ) {
				console.warn( "Could not enumerate screen methods:", e );
			}

				// Display public API methods
				const apiSection = document.createElement( "div" );
				apiSection.className = "section";
				apiSection.innerHTML = "<h2>Public API Methods</h2>";
				
				const apiList = document.createElement( "div" );
				apiList.className = "command-list";
				
				apiList.innerHTML = `<div class="count">Total Commands: ${publicMethods.length}</div>`;
				
				// Sort and display
				publicMethods.sort().forEach( method => {
					apiList.innerHTML += `<div class="command">$.${method}()</div>`;
				} );
				
				apiSection.appendChild( apiList );
				results.appendChild( apiSection );

				// Display screen methods
				if( screenMethods.length > 0 ) {
					const screenSection = document.createElement( "div" );
					screenSection.className = "section";
					screenSection.innerHTML = "<h2>Screen Instance Methods</h2>";
					
					const screenList = document.createElement( "div" );
					screenList.className = "command-list";
					
					screenList.innerHTML = `<div class="count">Total Methods: ${screenMethods.length}</div>`;
					
					screenMethods.sort().forEach( method => {
						screenList.innerHTML += `<div class="command">screen.${method}()</div>`;
					} );
					
					screenSection.appendChild( screenList );
					results.appendChild( screenSection );
				}

				// Display namespace structure
				const structureSection = document.createElement( "div" );
				structureSection.className = "section";
				structureSection.innerHTML = "<h2>API Namespace Structure</h2>";
				
				const structureList = document.createElement( "div" );
				structureList.className = "command-list";
				
				structureList.innerHTML = `
					<div class="command">âœ“ window.pi - Main API object</div>
					<div class="command">âœ“ window.$ - Preferred alias (same as pi)</div>
				`;
				
				// Check for _ namespace
				if( pi._ ) {
					structureList.innerHTML += `<div class="command">âœ“ pi._ - Internal API (for plugins)</div>`;
					const internalKeys = Object.keys( pi._ ).sort();
					internalKeys.forEach( key => {
						structureList.innerHTML += `<div class="command">  â””â”€ pi._.${key}</div>`;
					} );
				}
				
				// Check for util namespace
				if( pi.util ) {
					const utilCount = Object.keys( pi.util ).length;
					structureList.innerHTML += `<div class="command">âœ“ pi.util - ${utilCount} utility functions</div>`;
				}
				
				structureSection.appendChild( structureList );
				results.appendChild( structureSection );

				// Display implemented commands by category
				const implSection = document.createElement( "div" );
				implSection.className = "section";
				implSection.innerHTML = "<h2>Implemented Commands by Category</h2>";
				
				const implList = document.createElement( "div" );
				implList.className = "command-list";
				
				implList.innerHTML = `
					<div class="category">Core System (Phase 1):</div>
					<div class="command">â€¢ $.ready(callback) - Execute when Pi.js is loaded</div>
					<div class="command">â€¢ $.setScreen(screen) - Set active screen</div>
					<div class="command">â€¢ $.getScreen(id) - Get screen by ID</div>
					<div class="command">â€¢ $.removeAllScreens() - Remove all screens</div>
					<div class="command">â€¢ $.setDefaultColor(color) - Set default drawing color</div>
					<div class="command">â€¢ $.setDefaultPal(palette) - Set default palette</div>
					<div class="command">â€¢ $.getDefaultPal() - Get default palette</div>
					<div class="command">â€¢ $.setDefaultInputFocus(element) - Set input focus</div>
					<div class="command">â€¢ $.set(options) - Global settings</div>

					<div class="category">Screen Management (Phase 2):</div>
					<div class="command">â€¢ $.screen(aspect, container?, options?) - Create screen/canvas</div>
					<div class="command">â€¢ screen.width() - Get screen width</div>
					<div class="command">â€¢ screen.height() - Get screen height</div>
					<div class="command">â€¢ screen.canvas() - Get canvas element</div>
					<div class="command">â€¢ screen.setBgColor(color) - Set background color</div>
					<div class="command">â€¢ screen.setContainerBgColor(color) - Set container bg</div>
					<div class="command">â€¢ screen.findColor(color) - Find/add color to palette</div>
					<div class="command">â€¢ screen.cls(x?, y?, width?, height?) - Clear screen</div>
					<div class="command">â€¢ screen.render() - Render to canvas</div>
					<div class="command">â€¢ screen.removeScreen() - Remove this screen</div>

					<div class="category">Drawing Commands (Phase 4):</div>
					<div class="command">â€¢ screen.pset(x, y) - Set pixel</div>
					<div class="command">â€¢ screen.line(x1, y1, x2, y2) - Draw line (Bresenham)</div>
					<div class="command">â€¢ screen.circle(x, y, radius, fillColor?) - Draw circle</div>
					<div class="command">â€¢ screen.rect(x, y, w, h, fillColor?) - Draw rectangle</div>

					<div class="category">Utility Functions (Phase 0):</div>
					<div class="command">â€¢ pi.util.* - ${Object.keys( pi.util || {} ).length} utility functions</div>
					<div class="command">  â””â”€ Color conversion, math helpers, type checking, etc.</div>

					<div class="category">Plugin API (pi._):</div>
					<div class="command">â€¢ pi._.addCommand() - Register single command</div>
					<div class="command">â€¢ pi._.addCommands() - Register dual pixel/AA command</div>
					<div class="command">â€¢ pi._.addSetting() - Register setting</div>
					<div class="command">â€¢ pi._.addPen() - Register pen mode</div>
					<div class="command">â€¢ pi._.addBlendCommand() - Register blend mode</div>
					<div class="command">â€¢ pi._.data - Access internal data store</div>
					<div class="command">â€¢ pi._.parseOptions() - Parse command parameters</div>
				`;
				
				implSection.appendChild( implList );
				results.appendChild( implSection );

				// Display utils
				if( pi.util ) {
					const utilsSection = document.createElement( "div" );
					utilsSection.className = "section";
					utilsSection.innerHTML = "<h2>Utility Functions (pi.util.*)</h2>";
					
					const utilsList = document.createElement( "div" );
					utilsList.className = "command-list";
					
					const utils = Object.keys( pi.util ).sort();
					utilsList.innerHTML = `<div class="count">Total: ${utils.length}</div>`;
					
					utils.forEach( util => {
						utilsList.innerHTML += `<div class="command">pi.util.${util}</div>`;
					} );
					
					utilsSection.appendChild( utilsList );
					results.appendChild( utilsSection );
				}

			// API Comparison section
			if( legacyAPI ) {
				const compSection = document.createElement( "div" );
				compSection.className = "section";
				compSection.innerHTML = "<h2>API Comparison: v1.2.4 vs v2.0</h2>";
				
				const compList = document.createElement( "div" );
				compList.className = "command-list";

				// Compare global methods
				const legacyGlobal = new Set( legacyAPI.global );
				const currentGlobal = new Set( publicMethods );
				
				const newCommands = publicMethods.filter( m => !legacyGlobal.has( m ) );
				const missingCommands = legacyAPI.global.filter( m => !currentGlobal.has( m ) );
				const sharedCommands = publicMethods.filter( m => legacyGlobal.has( m ) );

				// Compare screen methods
				const legacyScreen = new Set( legacyAPI.screen );
				const currentScreen = new Set( screenMethods );
				
				const newScreenCommands = screenMethods.filter( m => !legacyScreen.has( m ) );
				const missingScreenCommands = legacyAPI.screen.filter( m => !currentScreen.has( m ) );
				const sharedScreenCommands = screenMethods.filter( m => legacyScreen.has( m ) );

				compList.innerHTML = `
					<div class="category">Global Commands:</div>
					<div class="command">v1.2.4: <span class="count">${legacyAPI.global.length}</span> commands</div>
					<div class="command">v2.0: <span class="count">${publicMethods.length}</span> commands</div>
					<div class="command">Shared: <span class="count" style="color: #4CAF50;">${sharedCommands.length}</span></div>
					<div class="command">New in v2.0: <span class="count" style="color: #2196F3;">${newCommands.length}</span></div>
					<div class="command">Missing from v2.0: <span class="count" style="color: #f44336;">${missingCommands.length}</span></div>
					
					<div class="category">Screen Commands:</div>
					<div class="command">v1.2.4: <span class="count">${legacyAPI.screen.length}</span> commands</div>
					<div class="command">v2.0: <span class="count">${screenMethods.length}</span> commands</div>
					<div class="command">Shared: <span class="count" style="color: #4CAF50;">${sharedScreenCommands.length}</span></div>
					<div class="command">New in v2.0: <span class="count" style="color: #2196F3;">${newScreenCommands.length}</span></div>
					<div class="command">Missing from v2.0: <span class="count" style="color: #f44336;">${missingScreenCommands.length}</span></div>
				`;

				// Show new commands
				if( newCommands.length > 0 ) {
					compList.innerHTML += `<div class="category">New Global Commands in v2.0:</div>`;
					newCommands.sort().forEach( cmd => {
						compList.innerHTML += `<div class="command" style="color: #2196F3;">+ $.${cmd}()</div>`;
					} );
				}

				if( newScreenCommands.length > 0 ) {
					compList.innerHTML += `<div class="category">New Screen Commands in v2.0:</div>`;
					newScreenCommands.sort().forEach( cmd => {
						compList.innerHTML += `<div class="command" style="color: #2196F3;">+ screen.${cmd}()</div>`;
					} );
				}

				// Show missing commands
				if( missingCommands.length > 0 ) {
					compList.innerHTML += `<div class="category">Missing Global Commands (from v1.2.4):</div>`;
					missingCommands.sort().forEach( cmd => {
						compList.innerHTML += `<div class="command" style="color: #f44336;">- $.${cmd}()</div>`;
					} );
				}

				if( missingScreenCommands.length > 0 ) {
					compList.innerHTML += `<div class="category">Missing Screen Commands (from v1.2.4):</div>`;
					missingScreenCommands.sort().forEach( cmd => {
						compList.innerHTML += `<div class="command" style="color: #f44336;">- screen.${cmd}()</div>`;
					} );
				}

				compSection.appendChild( compList );
				results.appendChild( compSection );
			}

			// Next steps
			const nextSection = document.createElement( "div" );
			nextSection.className = "section";
			nextSection.innerHTML = `
				<h2>Remaining Phases</h2>
				<div class="status">
					<ul>
						<li>ðŸ”„ Phase 18: Testing & Bug Fixing - Visual regression, unit tests</li>
						<li>Phase 19: Documentation - API reference, migration guide</li>
						<li>Phase 20: Release Preparation - Version bump, changelog</li>
					</ul>
					<br>
					<h3 style="color: #4CAF50;">ðŸŽ‰ Core Porting Complete!</h3>
					<p style="color: #4CAF50;">All 17 core phases finished! 226KB unminified, 110KB minified.</p>
					<p style="color: #FFC107;">Next: Polish, test, document, and release v2.0.0!</p>
				</div>
			`;
			results.appendChild( nextSection );

			console.log( "Pi.js loaded successfully!" );
			console.log( "pi object:", pi );
			console.log( "$ alias:", $ );
			console.log( "Public methods:", publicMethods );
			
			if( legacyAPI ) {
				console.log( "Legacy API comparison:", {
					"v1.2.4 global": legacyAPI.global.length,
					"v2.0 global": publicMethods.length,
					"v1.2.4 screen": legacyAPI.screen.length,
					"v2.0 screen": screenMethods.length
				} );
			}

			} catch( e ) {
				results.innerHTML = `
					<div class="section">
						<h2 style="color: #f44336;">Error Loading API</h2>
						<div>Build the project first with: <code>npm run build</code></div>
						<pre style="color: #f44336;">${e.message}\n${e.stack}</pre>
					</div>
				`;
				console.error( "Failed to load Pi.js:", e );
			}
		}

		// Compare and display results
		async function compareVersions() {
			try {
				await loadLegacy();
				console.log( "âœ“ Legacy version loaded", legacyAPI );
			} catch( e ) {
				console.warn( "Could not load legacy version:", e.message );
			}

			try {
				await loadCurrent();
				console.log( "âœ“ Current version loaded", currentAPI );
				console.log( "window.pi available:", !!window.pi );
				console.log( "window.$ available:", !!window.$ );
			} catch( e ) {
				console.error( "Could not load current version:", e );
				results.innerHTML = `
					<div class="section">
						<h2 style="color: #f44336;">Error Loading Current Version</h2>
						<pre style="color: #f44336;">${e.message}\n${e.stack}</pre>
					</div>
				`;
				return;
			}

			// Now run the inspection with comparison
			inspectAPI();
		}

		// Start the comparison process
		compareVersions();

		setTimeout( () => {
			document.body.style.overflow = "";
		}, 100 );
	</script>
</body>
</html>
