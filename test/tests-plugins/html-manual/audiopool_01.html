<!DOCTYPE html>
<html>
<head>
	<title>Audio Pool Test 1</title>
	<meta charset="utf-8">
	<style>
		body {
			font-family: Arial, sans-serif;
			padding: 20px;
			background: #222;
			color: #fff;
		}
		button {
			margin: 10px;
			padding: 10px 20px;
			font-size: 16px;
			cursor: pointer;
		}
		.section {
			margin-bottom: 30px;
			padding: 20px;
			background: #333;
			border-radius: 5px;
		}
		pre {
			background: #111;
			padding: 10px;
			border-radius: 5px;
			overflow-x: auto;
		}
		#status {
			background: #111;
			padding: 10px;
			border-radius: 5px;
			margin-top: 10px;
			min-height: 20px;
		}
	</style>
</head>
<body>
	<h1>Audio Pool Test</h1>

	<div class="section">
		<h2>Audio Pool Info</h2>
		<p>Audio pools allow you to play the same sound multiple times simultaneously.</p>
		<p>Each pool maintains multiple instances of the same audio file that can play overlapping.</p>
		<div id="status">Ready to load audio...</div>
	</div>

	<div class="section">
		<h2>Setup</h2>
		<button onclick="loadAudio()">Load Test Audio</button>
		<p>Note: This test uses a data URL beep sound since we don't have audio files in the repo.</p>
	</div>

	<div class="section">
		<h2>Play Sounds</h2>
		<button onclick="playSingleSound()">Play Once</button>
		<button onclick="playRapidFire()">Rapid Fire (5x)</button>
		<button onclick="playOverlapping()">Overlapping (3x with delay)</button>
		<button onclick="stopPool()">Stop All</button>
	</div>

	<div class="section">
		<h2>Volume Control</h2>
		<button onclick="playWithVolume(1.0)">Play at 100%</button>
		<button onclick="playWithVolume(0.5)">Play at 50%</button>
		<button onclick="playWithVolume(0.25)">Play at 25%</button>
	</div>

	<script src="../../../build/pi.js"></script>
	<script src="../../../build/plugins/play-sound/play-sound.js"></script>
	<script>
		let audioPoolId = null;

		// Generate a simple beep sound as a data URL
		// This creates a 0.5 second 440Hz beep using Web Audio API
		function generateBeepDataURL() {
			const audioContext = new ( window.AudioContext || window.webkitAudioContext )();
			const sampleRate = audioContext.sampleRate;
			const duration = 0.5;
			const frequency = 440;
			const numSamples = Math.floor( sampleRate * duration );
			const buffer = audioContext.createBuffer( 1, numSamples, sampleRate );
			const data = buffer.getChannelData( 0 );

			for( let i = 0; i < numSamples; i++ ) {
				data[ i ] = Math.sin( 2 * Math.PI * frequency * i / sampleRate ) * 0.3;
			}

			// Convert to WAV format
			const wav = audioBufferToWav( buffer );
			const blob = new Blob( [ wav ], { "type": "audio/wav" } );
			return URL.createObjectURL( blob );
		}

		// Convert AudioBuffer to WAV format
		function audioBufferToWav( buffer ) {
			const numChannels = buffer.numberOfChannels;
			const sampleRate = buffer.sampleRate;
			const format = 1;
			const bitDepth = 16;
			const bytesPerSample = bitDepth / 8;
			const blockAlign = numChannels * bytesPerSample;

			const length = buffer.length;
			const arrayBuffer = new ArrayBuffer( 44 + length * numChannels * bytesPerSample );
			const view = new DataView( arrayBuffer );

			// WAV header
			const writeString = ( offset, string ) => {
				for( let i = 0; i < string.length; i++ ) {
					view.setUint8( offset + i, string.charCodeAt( i ) );
				}
			};

			writeString( 0, "RIFF" );
			view.setUint32( 4, 36 + length * numChannels * bytesPerSample, true );
			writeString( 8, "WAVE" );
			writeString( 12, "fmt " );
			view.setUint32( 16, 16, true );
			view.setUint16( 20, format, true );
			view.setUint16( 22, numChannels, true );
			view.setUint32( 24, sampleRate, true );
			view.setUint32( 28, sampleRate * blockAlign, true );
			view.setUint16( 32, blockAlign, true );
			view.setUint16( 34, bitDepth, true );
			writeString( 36, "data" );
			view.setUint32( 40, length * numChannels * bytesPerSample, true );

			// Convert float samples to 16-bit PCM
			let offset = 44;
			for( let i = 0; i < length; i++ ) {
				for( let channel = 0; channel < numChannels; channel++ ) {
					const sample = Math.max( -1, Math.min( 1, buffer.getChannelData( channel )[ i ] ) );
					view.setInt16( offset, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true );
					offset += 2;
				}
			}

			return arrayBuffer;
		}

		function loadAudio() {
			const status = document.getElementById( "status" );
			status.textContent = "Generating audio and loading pool with 5 instances...";

			try {

				// Note: In a real application, use an actual audio file URL
				// audioPoolId = $.createAudioPool( "sounds/beep.mp3", 5 );
				
				// For testing without external files, we generate a beep sound
				const audioUrl = generateBeepDataURL();
				audioPoolId = $.createAudioPool( audioUrl, 5 );

				// Wait for audio to load and pi to be ready
				$.ready( () => {

					// Check if pool is ready by verifying it has loaded audio
					const checkPoolReady = () => {
						try {

							// Try to get pool info - if it throws, pool isn't ready
							// We'll wait a bit more for async loading
							setTimeout( () => {
								status.textContent = "Audio pool loaded successfully! Pool ID: " +
									audioPoolId + " (Click a play button to test)";
							}, 500 );
						} catch( error ) {
							setTimeout( checkPoolReady, 100 );
						}
					};
					checkPoolReady();
				} );
			} catch( error ) {
				status.textContent = "Error: " + error.message;
				console.error( error );
			}
		}

		function playSingleSound() {
			if( !audioPoolId ) {
				alert( "Please load audio first!" );
				return;
			}

			try {
				$.playAudioPool( audioPoolId, 1.0 );
				console.log( "Playing sound from pool:", audioPoolId );
			} catch( error ) {
				alert( "Error: " + error.message );
				console.error( error );
			}
		}

		function playRapidFire() {
			if( !audioPoolId ) {
				alert( "Please load audio first!" );
				return;
			}

			try {

				// Play 5 sounds in rapid succession
				// The audio pool ensures they can all play simultaneously
				for( let i = 0; i < 5; i++ ) {
					setTimeout( () => {
						$.playAudioPool( audioPoolId );
					}, i * 100 );
				}
			} catch( error ) {
				alert( "Error: " + error.message );
				console.error( error );
			}
		}

		function playOverlapping() {
			if( !audioPoolId ) {
				alert( "Please load audio first!" );
				return;
			}

			try {

				// Play 3 sounds with longer delays so they overlap
				for( let i = 0; i < 3; i++ ) {
					setTimeout( () => {
						$.playAudioPool( audioPoolId, 1.0, 0, 1.5 );
					}, i * 500 );
				}
			} catch( error ) {
				alert( "Error: " + error.message );
				console.error( error );
			}
		}

		function playWithVolume( volume ) {
			if( !audioPoolId ) {
				alert( "Please load audio first!" );
				return;
			}

			try {
				$.playAudioPool( audioPoolId, volume );
			} catch( error ) {
				alert( "Error: " + error.message );
				console.error( error );
			}
		}

		function stopPool() {
			if( !audioPoolId ) {
				alert( "Please load audio first!" );
				return;
			}

			try {
				$.stopAudioPool( audioPoolId );
			} catch( error ) {
				alert( "Error: " + error.message );
				console.error( error );
			}
		}
	</script>
</body>
</html>

